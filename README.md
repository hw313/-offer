# 剑指offer
- python 刷题，希望有好结果
- 下面是解题思路

> 第11题 找到2进制中1的个数，实现了按照逻辑的方法，这里注意在python中与0xffffffff相与等价于加上pow(2,32)，并且负数可以通过这个操作转为正数的情况。注意有，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。

> 第25题 复杂链表的复制，比简单链表多了一个random 指针，可随机指向链表中任一结点。具体可分为三步：
- 在初始链表中复制每个节点，如：复制节点A得到A1，将A1插入节点A后面
- 遍历链表，A1->random = A->random->next;得到random 的复制
- 分隔成两个链表，偶数位的即新链表
> 第26题，将二叉搜索树转为排序的双向链表，进行中序遍历得到含结点的list，每个元素的右孩子指向它的右边结点，每个元素的左孩子指向它的左边
> 第27题，字符串的全排列，递归固定一个结点，剩下的元素做全排列

> 第31题，整数中1出现的次数，将其看成字符串，拼在一起即可

> 第32题，把数组排成最小的数并拼接起来，思路是把两个数字转为字符串并拼接，如比较3 和 31 则 变为比较 ‘331’ 和‘313’ ，再转为数字即可进行比较。因此定义一个cmp 比较函数，利用functools的cmp_to_key函数即可进行排序。
 sorted(numbers, key = functools.cmp_to_key(self.cmp))
> 第33题，丑数，可以知道每个都是2,3,5的倍数，首先添加1，其次维护当前最小的丑数，如果是则下面3个数列的Index 右移
> 第35题 数组中的逆序对，利用归并排序，每次当左边的元素大于右边元素时，逆序对+1
> 第39题，判断是否为平衡二叉树。容易想到的方法是从上往下，判断左右子树的高度差是否<=1，然后继续递归判断左右子树 ，但是会有重复
因此考虑从下往上，如果子树非平衡二叉树即返回false，不需要进行判断
判断数的高度的代码如下:
```
def get_depth(root):
	if root is None:
		return 0
	return max(get_depth(root.left), get_depth(root.right))+1
```
>第48题，不用加减乘除做加法，异或^表示没有进位的相加，相与&表示进位，循环一直进行当进位=0退出，主要py防止溢出每次0xFFFFFFFF相与
结果如果《=0x7FFFFFFF,正数即返回,否则负数返回 ~(a^0xFFFFFFFF)


